<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Element中dialog组建实现拖拽</title>
      <link href="/vue-dialog-drag/"/>
      <url>/vue-dialog-drag/</url>
      
        <content type="html"><![CDATA[<ul><li><p>1.utils文件夹下创建<code>dialog.js</code>文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v-dialogDrag: 弹窗拖拽</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;dialogDrag&#x27;</span>, &#123;</span><br><span class="line">  bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> dialogHeaderEl = el.querySelector(<span class="string">&#x27;.el-dialog__header&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> dragDom = el.querySelector(<span class="string">&#x27;.el-dialog&#x27;</span>)</span><br><span class="line">    dialogHeaderEl.style.cursor = <span class="string">&#x27;move&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原有属性 ie dom元素.currentStyle 火狐谷歌 window.getComputedStyle(dom元素, null);</span></span><br><span class="line">    <span class="keyword">const</span> sty = dragDom.currentStyle || <span class="built_in">window</span>.getComputedStyle(dragDom, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    dialogHeaderEl.onmousedown = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 鼠标按下，计算当前元素距离可视区的距离</span></span><br><span class="line">      <span class="keyword">const</span> disX = e.clientX - dialogHeaderEl.offsetLeft</span><br><span class="line">      <span class="keyword">const</span> disY = e.clientY - dialogHeaderEl.offsetTop</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取到的值带px 正则匹配替换</span></span><br><span class="line">      <span class="keyword">let</span> styL, styT</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意在ie中 第一次获取到的值为组件自带50% 移动之后赋值为px</span></span><br><span class="line">      <span class="keyword">if</span> (sty.left.includes(<span class="string">&#x27;%&#x27;</span>)) &#123;</span><br><span class="line">        styL = +<span class="built_in">document</span>.body.clientWidth * (+sty.left.replace(<span class="regexp">/\%/g</span>, <span class="string">&#x27;&#x27;</span>) / <span class="number">100</span>)</span><br><span class="line">        styT = +<span class="built_in">document</span>.body.clientHeight * (+sty.top.replace(<span class="regexp">/\%/g</span>, <span class="string">&#x27;&#x27;</span>) / <span class="number">100</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        styL = +sty.left.replace(<span class="regexp">/\px/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        styT = +sty.top.replace(<span class="regexp">/\px/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 通过事件委托，计算移动的距离</span></span><br><span class="line">        <span class="keyword">const</span> l = e.clientX - disX</span><br><span class="line">        <span class="keyword">const</span> t = e.clientY - disY</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动当前元素</span></span><br><span class="line">        dragDom.style.left = <span class="string">`<span class="subst">$&#123;l + styL&#125;</span>px`</span></span><br><span class="line">        dragDom.style.top = <span class="string">`<span class="subst">$&#123;t + styT&#125;</span>px`</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将此时的位置传出去</span></span><br><span class="line">        <span class="comment">// binding.value(&#123;x:e.pageX,y:e.pageY&#125;)</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.onmousemove = <span class="literal">null</span></span><br><span class="line">        <span class="built_in">document</span>.onmouseup = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>2.在<code>main.js</code>中全局引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./utils/dialog&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>3.使用方法：给el-dialog 添加 v-dialog-drag属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog v-dialog-drag&gt;&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
            <tag> Element UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos删除大量文件</title>
      <link href="/delete-a-large-number-of-files/"/>
      <url>/delete-a-large-number-of-files/</url>
      
        <content type="html"><![CDATA[<p>今天在查看服务器时发现磁盘使用率巨高，新加的200G云盘已经用了70%多</p><p>经过排查发现是crontab的输出记录，文件路径是<br><code>/var/spool/postfix/maildrop</code></p><p>尝试 <code>rm -rf *</code></p><p>结果提示 <code>Argument list too long</code></p><p>文件太多无法直接删掉</p><p>于是执行以下命令将文件10个分为一组进行删除</p><p><code>ls | xargs -n 10 rm -rf</code></p><p>耗时几十分钟,删除成功</p>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETH量化交易工具(支持ERC20代币)</title>
      <link href="/eth-quantitative-transaction/"/>
      <url>/eth-quantitative-transaction/</url>
      
        <content type="html"><![CDATA[<p>#项目起源<br>ERC20代币空投不断，朋友告诉我可以以此来薅羊毛并且有人以此获利数十万，于是这个项目就诞生了。</p><p>这个项目可以批量生成地址，批量交易ETH或ERC20代币</p><p>支持一对多、多对一、多对多交易</p><p>我自己试过几次，手续费有点感人，大概￥50交易一次，批量养号的话我是养不起的，如果有大佬想合作可以联系我<br>#项目地址<br><a href="http://eth.fsql.net/">http://eth.fsql.net/</a></p><p>暂时没考虑开源，想使用的小伙伴可以私信我获取账号</p>]]></content>
      
      
      
        <tags>
            
            <tag> eth </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获得新域名:loli.watch</title>
      <link href="/get-new-domain-loli-watch/"/>
      <url>/get-new-domain-loli-watch/</url>
      
        <content type="html"><![CDATA[<h3 id="有个loli梦"><a href="#有个loli梦" class="headerlink" title="有个loli梦"></a>有个loli梦</h3><p>一直想要个loli域名，后缀是什么无所谓，当然越短越好，.com .net这类主流后缀基本不用想了。今天逛godaddy偶然发现<a href="https://loli.watch/">loli.watch</a> 可买，首年只要$10。果断入手了</p><a id="more"></a><h3 id="与fsql-me共享GithubPages"><a href="#与fsql-me共享GithubPages" class="headerlink" title="与fsql.me共享GithubPages"></a>与fsql.me共享GithubPages</h3><ul><li>删除GithubPages仓库中的CNAME(不删除反代后会301重定向至CNAME绑定的域名,无法多域名共享)</li><li>nginx分别配置fsql.me和loli.watch的证书，并做反向代理</li><li>这样<a href="https://loli.watch/">loli.watch</a> 和 <a href="https://fsql.me/">fsql.me</a> 就都可以访问到博客了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE语音识别</title>
      <link href="/vue-voice-input-button/"/>
      <url>/vue-voice-input-button/</url>
      
        <content type="html"><![CDATA[<p>在很多场景下，当我们使用手机操作复杂页面时，会非常不方便，我在写一个商城后台时遇到了这个问题。运营经常需要很晚来操作后台，而很大一部分时间都是只能用手机，于是我想到的解决方案就是<strong>语音控制</strong></p><p>实现结果如下:<br><video id="video" controls="" preload="none" poster="/images/vue-voice-input-button-demo.jpg"><br>      <source id="mp4" src="/video/vue-voice-input-button-demo.mp4" type="video/mp4"><br></video></p><a id="more"></a><p>需要引入依赖</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install voice-input-button2 --save</span><br></pre></td></tr></table></figure><p>或者直接下载源码包</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/ferrinweb/voice-input-button2.git</span><br></pre></td></tr></table></figure><p>仓库地址<br><a href="https://github.com/ferrinweb/voice-input-button2">https://github.com/ferrinweb/voice-input-button2</a><br>该项目的语言识别接口是调用科大讯飞，需要先注册获取appid和key<br><a href="https://www.xfyun.cn/">注册地址：https://www.xfyun.cn/</a><br>按照文档配置好后可以正常使用了，但遇到一个小bug，因为商城的语音控制在修改库存时需要识别数字，按照文档需要设置以下参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:ptt &#x3D; 0</span><br><span class="line">:nunum &#x3D; 1</span><br></pre></td></tr></table></figure><p>但实际操作时，如果参数前不加<code>:</code>则会以字符串提交，这会使得WS直接报错</p><p>所以需要在<code>recorder/index.js</code>文件做修改，为ptt和nunum做字符串转数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">business: &#123;</span><br><span class="line">        language: <span class="built_in">this</span>.language,</span><br><span class="line">        domain: <span class="string">&quot;iat&quot;</span>,</span><br><span class="line">        accent: <span class="built_in">this</span>.accent,</span><br><span class="line">        vad_eos: <span class="built_in">this</span>.vad_eos,</span><br><span class="line">        dwa: <span class="string">&quot;wpgs&quot;</span>,</span><br><span class="line">        pd: <span class="built_in">this</span>.pd,</span><br><span class="line">        rlang: <span class="built_in">this</span>.rlang,</span><br><span class="line">        ptt: <span class="built_in">this</span>.ptt ? <span class="built_in">parseInt</span>(<span class="built_in">this</span>.ptt) : <span class="number">1</span>,</span><br><span class="line">        nunum: <span class="built_in">this</span>.nunum ? <span class="built_in">parseInt</span>(<span class="built_in">this</span>.nunum) : <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP魔术方法</title>
      <link href="/php-magic-methods/"/>
      <url>/php-magic-methods/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP的魔术方法"><a href="#PHP的魔术方法" class="headerlink" title="PHP的魔术方法"></a>PHP的魔术方法</h1><p>PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀</p><h2 id="PHP的16个魔术方法"><a href="#PHP的16个魔术方法" class="headerlink" title="PHP的16个魔术方法"></a>PHP的16个魔术方法</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__construct()，类的构造函数</span><br><span class="line">__destruct()，类的析构函数</span><br><span class="line">__call()，在对象中调用一个不可访问方法时调用</span><br><span class="line">__callStatic()，用静态方式中调用一个不可访问方法时调用</span><br><span class="line">__get()，获得一个类的成员变量时调用</span><br><span class="line">__set()，设置一个类的成员变量时调用</span><br><span class="line">__isset()，当对不可访问属性调用<span class="keyword">isset</span>()或<span class="keyword">empty</span>()时调用</span><br><span class="line">__unset()，当对不可访问属性调用<span class="keyword">unset</span>()时被调用。</span><br><span class="line">__sleep()，执行serialize()时，先会调用这个函数</span><br><span class="line">__wakeup()，执行unserialize()时，先会调用这个函数</span><br><span class="line">__toString()，类被当成字符串时的回应方法</span><br><span class="line">__invoke()，调用函数的方式调用一个对象时的回应方法</span><br><span class="line">__set_state()，调用var_export()导出类时，此静态方法会被调用。</span><br><span class="line">__clone()，当对象复制完成时调用</span><br><span class="line">__autoload()，尝试加载未定义的类</span><br><span class="line">__debugInfo()，打印所需调试信息</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="construct-，类的构造函数"><a href="#construct-，类的构造函数" class="headerlink" title="__construct()，类的构造函数"></a>__construct()，类的构造函数</h2><p>php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。</p><h3 id="1、-构造方法的作用"><a href="#1、-构造方法的作用" class="headerlink" title="1、 构造方法的作用"></a>1、 构造方法的作用</h3><p>通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。</p><h3 id="2、-构造方法的在类中的声明格式"><a href="#2、-构造方法的在类中的声明格式" class="headerlink" title="2、 构造方法的在类中的声明格式"></a>2、 构造方法的在类中的声明格式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__constrct</span>(<span class="params">[参数列表]</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    方法体 <span class="comment">//通常用来对成员属性进行初始化赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、-在类中声明构造方法需要注意的事项"><a href="#3、-在类中声明构造方法需要注意的事项" class="headerlink" title="3、 在类中声明构造方法需要注意的事项"></a>3、 在类中声明构造方法需要注意的事项</h3><blockquote><p>1、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。<br>2、构造方法名称是以两个下画线开始的__construct()</p></blockquote><p>下面是它的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    </span>&#123;                                                                      </span><br><span class="line">            <span class="keyword">public</span> $name;        </span><br><span class="line">            <span class="keyword">public</span> $age;        </span><br><span class="line">            <span class="keyword">public</span> $sex;        </span><br><span class="line">                                                                 </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 显示声明一个构造方法且带参数</span></span><br><span class="line"><span class="comment">         */</span>                                                                                       </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>, $sex=<span class="string">&quot;男&quot;</span>, $age=<span class="number">22</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;      </span><br><span class="line">            <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sex = $sex;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * say 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;我叫：&quot;</span> . <span class="keyword">$this</span>-&gt;name . <span class="string">&quot;，性别：&quot;</span> . <span class="keyword">$this</span>-&gt;sex . <span class="string">&quot;，年龄：&quot;</span> . <span class="keyword">$this</span>-&gt;age;</span><br><span class="line">        &#125;   </span><br><span class="line">                                                                                           </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建对象$Person1且不带任参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">echo</span> $Person1-&gt;say(); <span class="comment">//输出:我叫：，性别：男，年龄：27</span></span><br></pre></td></tr></table></figure><p>创建对象$Person2且带参数“小明”</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person2 = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> $Person2-&gt;say(); <span class="comment">//输出：我叫：张三，性别：男，年龄：27</span></span><br></pre></td></tr></table></figure><p>创建对象$Person3且带三个参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person3 = <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">echo</span> $Person3-&gt;say(); <span class="comment">//输出：我叫：李四，性别：男，年龄：25</span></span><br></pre></td></tr></table></figure><h2 id="destruct-，类的析构函数"><a href="#destruct-，类的析构函数" class="headerlink" title="__destruct()，类的析构函数"></a>__destruct()，类的析构函数</h2><p>通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。</p><p>析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。</p><p>析构方法是PHP5才引进的新内容。</p><p>析造方法的声明格式与构造方法 __construct() 比较类似，也是以两个下划线开始的方法 __destruct() ，这种析构方法名称也是固定的。</p><h3 id="1、-析构方法的声明格式"><a href="#1、-析构方法的声明格式" class="headerlink" title="1、 析构方法的声明格式"></a>1、 析构方法的声明格式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：析构函数不能带有任何参数。</p><h3 id="2、-析构方法的作用"><a href="#2、-析构方法的作用" class="headerlink" title="2、 析构方法的作用"></a>2、 析构方法的作用</h3><p>一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。<br>举例演示，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;     </span><br><span class="line">                                                        </span><br><span class="line">    <span class="keyword">public</span> $name;         </span><br><span class="line">    <span class="keyword">public</span> $age;         </span><br><span class="line">    <span class="keyword">public</span> $sex;         </span><br><span class="line">                                                                    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>, $sex=<span class="string">&quot;男&quot;</span>, $age=<span class="number">22</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * say 说话方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;我叫：&quot;</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">&quot;，性别：&quot;</span>.<span class="keyword">$this</span>-&gt;sex.<span class="string">&quot;，年龄：&quot;</span>.<span class="keyword">$this</span>-&gt;age;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明一个析构方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;我觉得我还可以再抢救一下，我的名字叫&quot;</span>.<span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$Person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="keyword">unset</span>($Person); <span class="comment">//销毁上面创建的对象$Person</span></span><br></pre></td></tr></table></figure><p>上面的程序运行时输出：</p><blockquote><p>我觉得我还可以再抢救一下，我的名字叫小明</p></blockquote><h2 id="call-，在对象中调用一个不可访问方法时调用。"><a href="#call-，在对象中调用一个不可访问方法时调用。" class="headerlink" title="__call()，在对象中调用一个不可访问方法时调用。"></a>__call()，在对象中调用一个不可访问方法时调用。</h2><p>该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。</p><h3 id="1、-call-方法的格式："><a href="#1、-call-方法的格式：" class="headerlink" title="1、 __call() 方法的格式："></a>1、 __call() 方法的格式：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="keyword">string</span> $function_name, <span class="keyword">array</span> $arguments</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、-call-方法的作用："><a href="#2、-call-方法的作用：" class="headerlink" title="2、 __call() 方法的作用："></a>2、 __call() 方法的作用：</h3><p>为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。</p><p>该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。<br>请参考如下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;                             </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">                              </span><br><span class="line">           <span class="keyword">echo</span> <span class="string">&quot;Hello, world!&lt;br&gt;&quot;</span>; </span><br><span class="line">    &#125;      </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明此方法用来处理调用对象中不存在的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params">$funName, $arguments</span>)</span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">          <span class="keyword">echo</span> <span class="string">&quot;你所调用的函数：&quot;</span> . $funName . <span class="string">&quot;(参数：&quot;</span> ;  <span class="comment">// 输出调用不存在的方法名</span></span><br><span class="line">          print_r($arguments); <span class="comment">// 输出调用不存在的方法时的参数列表</span></span><br><span class="line">          <span class="keyword">echo</span> <span class="string">&quot;)不存在！&lt;br&gt;\n&quot;</span>; <span class="comment">// 结束换行                      </span></span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;</span><br><span class="line">$Person = <span class="keyword">new</span> Person();            </span><br><span class="line">$Person-&gt;run(<span class="string">&quot;teacher&quot;</span>); <span class="comment">// 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span></span><br><span class="line">$Person-&gt;eat(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;苹果&quot;</span>);             </span><br><span class="line">$Person-&gt;say();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！<br>你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！<br>Hello, world!</p></blockquote><h2 id="callStatic-，用静态方式中调用一个不可访问方法时调用"><a href="#callStatic-，用静态方式中调用一个不可访问方法时调用" class="headerlink" title="__callStatic()，用静态方式中调用一个不可访问方法时调用"></a>__callStatic()，用静态方式中调用一个不可访问方法时调用</h2><p>此方法与上面所说的 __call() 功能除了 __callStatic() 是为静态方法准备的之外，其它都是一样的。</p><p>请看下面代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello, world!&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明此方法用来处理调用对象中不存在的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params">$funName, $arguments</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;你所调用的静态方法：&quot;</span> . $funName . <span class="string">&quot;(参数：&quot;</span> ;  <span class="comment">// 输出调用不存在的方法名</span></span><br><span class="line">        print_r($arguments); <span class="comment">// 输出调用不存在的方法时的参数列表</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;)不存在！&lt;br&gt;\n&quot;</span>; <span class="comment">// 结束换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = <span class="keyword">new</span> Person();</span><br><span class="line">$Person::run(<span class="string">&quot;teacher&quot;</span>); <span class="comment">// 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span></span><br><span class="line">$Person::eat(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">$Person-&gt;say();</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！<br>你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！<br>Hello, world!</p></blockquote><h2 id="get-，获得一个类的成员变量时调用"><a href="#get-，获得一个类的成员变量时调用" class="headerlink" title="__get()，获得一个类的成员变量时调用"></a>__get()，获得一个类的成员变量时调用</h2><p>在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。</p><h3 id="魔术方法-get-的作用"><a href="#魔术方法-get-的作用" class="headerlink" title="魔术方法__get()的作用"></a>魔术方法__get()的作用</h3><blockquote><p>在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。<br>我们通过下面的 __get() 的实例来更进一步的连接它吧：</p></blockquote><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $name;</span><br><span class="line">    <span class="keyword">private</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>, $age=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $propertyName</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params">$propertyName</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span> ($propertyName == <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;age &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;age - <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$propertyName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$propertyName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">60</span>);   <span class="comment">// 通过Person类实例化的对象，并通过构造方法为属性赋初值</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;姓名：&quot;</span> . $Person-&gt;name . <span class="string">&quot;&lt;br&gt;&quot;</span>;   <span class="comment">// 直接访问私有属性name，自动调用了__get()方法可以间接获取</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;年龄：&quot;</span> . $Person-&gt;age . <span class="string">&quot;&lt;br&gt;&quot;</span>;    <span class="comment">// 自动调用了__get()方法，根据对象本身的情况会返回不同的值</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>姓名：小明<br>年龄：50</p></blockquote><h2 id="set-，设置一个类的成员变量时调用"><a href="#set-，设置一个类的成员变量时调用" class="headerlink" title="__set()，设置一个类的成员变量时调用"></a>__set()，设置一个类的成员变量时调用</h2><h3 id="魔术方法-set-的作用："><a href="#魔术方法-set-的作用：" class="headerlink" title="魔术方法__set() 的作用："></a>魔术方法__set() 的作用：</h3><blockquote><p>__set( property,property,value )` 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。</p></blockquote><p>请看下面的演示代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $name;</span><br><span class="line">    <span class="keyword">private</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $property</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params">$property, $value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($property==<span class="string">&quot;age&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ($value &gt; <span class="number">150</span> || $value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$property = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在类中声明说话的方法，将所有的私有属性说出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;我叫&quot;</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">&quot;，今年&quot;</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">&quot;岁了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$Person=<span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">25</span>); <span class="comment">//注意，初始值将被下面所改变</span></span><br><span class="line"><span class="comment">//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数</span></span><br><span class="line">$Person-&gt;name = <span class="string">&quot;小红&quot;</span>;     <span class="comment">//赋值成功。如果没有__set()，则出错。</span></span><br><span class="line"><span class="comment">//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数</span></span><br><span class="line">$Person-&gt;age = <span class="number">16</span>; <span class="comment">//赋值成功</span></span><br><span class="line">$Person-&gt;age = <span class="number">160</span>; <span class="comment">//160是一个非法值，赋值失效</span></span><br><span class="line">$Person-&gt;say();  <span class="comment">//输出：我叫小红，今年16岁了</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>我叫小红，今年16岁了</p></blockquote><h2 id="isset-，当对不可访问属性调用isset-或empty-时调用"><a href="#isset-，当对不可访问属性调用isset-或empty-时调用" class="headerlink" title="__isset()，当对不可访问属性调用isset()或empty()时调用"></a>__isset()，当对不可访问属性调用isset()或empty()时调用</h2><p>在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。</p><p>那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？</p><p>分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个__isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的__isset()方法了帮我们完成这样的操作。</p><h3 id="魔术方法-isset-的作用"><a href="#魔术方法-isset-的作用" class="headerlink" title="魔术方法__isset()的作用"></a>魔术方法__isset()的作用</h3><blockquote><p>当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。</p></blockquote><p>请看下面代码演示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">private</span> $name;</span><br><span class="line">    <span class="keyword">private</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $content</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__isset</span>(<span class="params">$content</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">25</span>); <span class="comment">// 初始赋值</span></span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>($person-&gt;sex),<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>($person-&gt;name),<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>($person-&gt;age),<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>1 // public 可以 isset()<br>当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo<br>1 // __isset() 内第二个echo<br>当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo<br>1 // __isset() 内第二个echo</p></blockquote><h2 id="unset-，当对不可访问属性调用unset-时被调用。"><a href="#unset-，当对不可访问属性调用unset-时被调用。" class="headerlink" title="__unset()，当对不可访问属性调用unset()时被调用。"></a>__unset()，当对不可访问属性调用unset()时被调用。</h2><p>看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。</p><p>那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？</p><p>这里自然也是分两种情况：</p><p>1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。</p><p>2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。</p><p>虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上__unset()这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了__unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。</p><p>请看如下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">private</span> $name;</span><br><span class="line">    <span class="keyword">private</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $content</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unset</span>(<span class="params">$content</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">25</span>); <span class="comment">// 初始赋值</span></span><br><span class="line"><span class="keyword">unset</span>($person-&gt;sex);</span><br><span class="line"><span class="keyword">unset</span>($person-&gt;name);</span><br><span class="line"><span class="keyword">unset</span>($person-&gt;age);</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>当在类外部使用unset()函数来删除私有成员时自动调用的<br>1当在类外部使用unset()函数来删除私有成员时自动调用的<br>1</p></blockquote><h2 id="sleep-，执行serialize-时，先会调用这个函数"><a href="#sleep-，执行serialize-时，先会调用这个函数" class="headerlink" title="__sleep()，执行serialize()时，先会调用这个函数"></a>__sleep()，执行serialize()时，先会调用这个函数</h2><p>serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p><p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p><p>如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p><ul><li>注意：</li></ul><blockquote><p>__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。</p></blockquote><ul><li>作用：</li></ul><blockquote><p>__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。<br>具体请参考如下代码：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = base64_encode(<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>); <span class="comment">// 这里必须返回一个数值，里边的元素表示返回的属性名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line"><span class="keyword">echo</span> serialize($person);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><blockquote><p>当在类外部使用serialize()时会调用这里的__sleep()方法<br>O:6:”Person”:2:{s:4:”name”;s:8:”5bCP5piO”;s:3:”age”;i:25;}</p></blockquote><h2 id="wakeup-，执行unserialize-时，先会调用这个函数"><a href="#wakeup-，执行unserialize-时，先会调用这个函数" class="headerlink" title="__wakeup()，执行unserialize()时，先会调用这个函数"></a>__wakeup()，执行unserialize()时，先会调用这个函数</h2><p>如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。</p><p>那么为什么呢？</p><p>因为：</p><blockquote><p>与之相反，<code>unserialize()</code> 会检查是否存在一个 <code>__wakeup()</code> 方法。如果存在，则会先调用 <code>__wakeup</code> 方法，预先准备对象需要的资源。</p></blockquote><p>作用：</p><blockquote><p>__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。<br>还是看代码：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = base64_encode(<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>); <span class="comment">// 这里必须返回一个数值，里边的元素表示返回的属性名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * __wakeup</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="comment">// 这里不需要返回数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line">var_dump(serialize($person));</span><br><span class="line">var_dump(unserialize(serialize($person)));</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>当在类外部使用serialize()时会调用这里的__sleep()方法<br>string(58) “O:6:”Person”:2:{s:4:”name”;s:8:”5bCP5piO”;s:3:”age”;i:25;}” 当在类外部使用serialize()时会调用这里的__sleep()方法<br>当在类外部使用unserialize()时会调用这里的__wakeup()方法<br>object(Person)#2 (3) { [“sex”]=&gt; string(3) “男” [“name”]=&gt; int(2) [“age”]=&gt; int(25) }</p></blockquote><h2 id="toString-，类被当成字符串时的回应方法"><a href="#toString-，类被当成字符串时的回应方法" class="headerlink" title="__toString()，类被当成字符串时的回应方法"></a>__toString()，类被当成字符串时的回应方法</h2><p>作用：</p><blockquote><p>__toString() 方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code> 应该显示些什么。</p></blockquote><p>注意：</p><blockquote><p>此方法必须返回一个字符串，否则将发出一条 <code>E_RECOVERABLE_ERROR</code> 级别的致命错误。</p></blockquote><p>警告：</p><blockquote><p>不能在 __toString() 方法中抛出异常。这么做会导致致命错误。</p></blockquote><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&#x27;go go go&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line"><span class="keyword">echo</span> $person;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>go go go</p></blockquote><p>那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下：</p><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line"><span class="keyword">echo</span> $person;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>Catchable fatal error: Object of class Person could not be converted to string in D:\phpStudy\WWW\test\index.php on line 18</p></blockquote><p>很明显，页面报了一个致命错误，这是语法所不允许的。</p><h2 id="invoke-，调用函数的方式调用一个对象时的回应方法"><a href="#invoke-，调用函数的方式调用一个对象时的回应方法" class="headerlink" title="__invoke()，调用函数的方式调用一个对象时的回应方法"></a>__invoke()，调用函数的方式调用一个对象时的回应方法</h2><p>作用：</p><blockquote><p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</p></blockquote><p>注意：</p><blockquote><p>本特性只在 PHP 5.3.0 及以上版本有效。</p></blockquote><p>直接上代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;这可是一个对象哦&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line">$person();</span><br></pre></td></tr></table></figure><p>查看运行结果：</p><blockquote><p>这可是一个对象哦</p></blockquote><p>当然，如果你执意要将对象当函数方法使用，那么会得到下面结果：</p><blockquote><p>Fatal error: Function name must be a string in D:\phpStudy\WWW\test\index.php on line 18</p></blockquote><h2 id="set-state-，调用var-export-导出类时，此静态方法会被调用。"><a href="#set-state-，调用var-export-导出类时，此静态方法会被调用。" class="headerlink" title="__set_state()，调用var_export()导出类时，此静态方法会被调用。"></a>__set_state()，调用var_export()导出类时，此静态方法会被调用。</h2><p>作用：</p><blockquote><p>自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。</p></blockquote><p>参数：</p><blockquote><p>本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。<br>下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何：</p></blockquote><p>上代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line">var_export($person);</span><br></pre></td></tr></table></figure><p>看结果：</p><blockquote><p>Person::__set_state(array( ‘sex’ =&gt; ‘男’, ‘name’ =&gt; ‘小明’, ‘age’ =&gt; 25, ))</p></blockquote><p>很明显，将对象中的属性都打印出来了</p><p>加了 __set_state() 之后：</p><p>继续上代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__set_state</span>(<span class="params">$an_array</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $a = <span class="keyword">new</span> Person();</span><br><span class="line">        $a-&gt;name = $an_array[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">        <span class="keyword">return</span> $a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line">$person-&gt;name = <span class="string">&#x27;小红&#x27;</span>;</span><br><span class="line">var_export($person);</span><br></pre></td></tr></table></figure><p>继续看结果：</p><blockquote><p>Person::__set_state(array( ‘sex’ =&gt; ‘男’, ‘name’ =&gt; ‘小红’, ‘age’ =&gt; 25, ))</p></blockquote><h2 id="clone-，当对象复制完成时调用"><a href="#clone-，当对象复制完成时调用" class="headerlink" title="__clone()，当对象复制完成时调用"></a>__clone()，当对象复制完成时调用</h2><p>在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。</p><p>作用：</p><blockquote><p>对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。</p></blockquote><p>语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$copy_of_object = <span class="keyword">clone</span> $object;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。<br>当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。</p></blockquote><p>看代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name=<span class="string">&quot;&quot;</span>,  $age=<span class="number">25</span>, $sex=<span class="string">&#x27;男&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age  = $age;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__METHOD__</span>.<span class="string">&quot;你正在克隆对象&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">// 初始赋值</span></span><br><span class="line">$person2 = <span class="keyword">clone</span> $person;</span><br><span class="line"></span><br><span class="line">var_dump(<span class="string">&#x27;persion1:&#x27;</span>);</span><br><span class="line">var_dump($person);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&#x27;persion2:&#x27;</span>);</span><br><span class="line">var_dump($person2);</span><br></pre></td></tr></table></figure><p>看结果：</p><blockquote><p>Person::__clone你正在克隆对象<br>string(9) “persion1:” object(Person)#1 (3) { [“sex”]=&gt; string(3) “男” [“name”]=&gt; string(6) “小明” [“age”]=&gt; int(25) }<br>string(9) “persion2:” object(Person)#2 (3) { [“sex”]=&gt; string(3) “男” [“name”]=&gt; string(6) “小明” [“age”]=&gt; int(25) }</p></blockquote><p>克隆成功。</p><h2 id="autoload-，尝试加载未定义的类"><a href="#autoload-，尝试加载未定义的类" class="headerlink" title="__autoload()，尝试加载未定义的类"></a>__autoload()，尝试加载未定义的类</h2><p>作用：</p><blockquote><p>你可以通过定义这个函数来启用类的自动加载。</p></blockquote><p>在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。<br>但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。<br>还是通过例子来看看吧：<br>先看看以往的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 文件non_autoload.php </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">   </span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;project/class/A.php&#x27;</span>);  </span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;project/class/B.php&#x27;</span>);  </span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;project/class/C.php&#x27;</span>);  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (条件A) &#123;  </span><br><span class="line">    $a = <span class="keyword">new</span> A();  </span><br><span class="line">    $b = <span class="keyword">new</span> B();  </span><br><span class="line">    $c = <span class="keyword">new</span> C();  </span><br><span class="line">    <span class="comment">// … 业务逻辑  </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件B) &#123;  </span><br><span class="line">    $a = newA();  </span><br><span class="line">    $b = <span class="keyword">new</span> B();  </span><br><span class="line">    <span class="comment">// … 业务逻辑  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。</p><p>那么如果使用 __autoload() 方式呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 文件autoload_demo.php </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">__autoload</span>(<span class="params">$className</span>) </span>&#123;  </span><br><span class="line">    $filePath = “project/<span class="class"><span class="keyword">class</span>/</span>&#123;$className&#125;.php”;  </span><br><span class="line">    <span class="keyword">if</span> (is_readable($filePath)) &#123;  </span><br><span class="line">        <span class="keyword">require</span>($filePath);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (条件A) &#123;  </span><br><span class="line">    $a = <span class="keyword">new</span> A();  </span><br><span class="line">    $b = <span class="keyword">new</span> B();  </span><br><span class="line">    $c = <span class="keyword">new</span> C();  </span><br><span class="line">    <span class="comment">// … 业务逻辑  </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件B) &#123;  </span><br><span class="line">    $a = newA();  </span><br><span class="line">    $b = <span class="keyword">new</span> B();  </span><br><span class="line">    <span class="comment">// … 业务逻辑  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。<br>再来看看这里的效率如何，我们分析下：<br>当php引擎第一次使用类A，但是找不到时，会自动调用 __autoload 方法，并将类名“A”作为参数传入。所以，我们在 __autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。<br>注意：</p><blockquote><p>这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用__autoload，而是直接使用内存中的类A，不会导致多次包含。</p></blockquote><p>扩展：</p><blockquote><p>其实php发展到今天，已经有将 <code>spl_autoload_register</code> — 注册给定的函数作为 __autoload 的实现了，但是这个不在啊本文讲解之内，有兴趣可以自行看手册。</p></blockquote><h2 id="debugInfo-，打印所需调试信息"><a href="#debugInfo-，打印所需调试信息" class="headerlink" title="__debugInfo()，打印所需调试信息"></a>__debugInfo()，打印所需调试信息</h2><p>注意：</p><blockquote><p>该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。</p></blockquote><p>看代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $prop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;prop = $val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__debugInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&#x27;propSquared&#x27;</span> =&gt; <span class="keyword">$this</span>-&gt;prop ** <span class="number">2</span>,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(<span class="keyword">new</span> C(<span class="number">42</span>));</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>object(C)#1 (1) { [“propSquared”]=&gt; int(1764) }</p></blockquote><p>再次注意：</p><blockquote><p>这里的 <code>**</code> 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是PHP中我了解到的魔术方法了，常用的包括 __set() __get() __autoload() 等应该熟悉，其他的了解也没有关系，毕竟知识不怕多嘛。</p><p>好了，有兴趣的或者我这里没有说明白的，可以参考啊官方文档。</p><p>PHP在线手册地址：<a href="http://php.net/manual/zh/">http://php.net/manual/zh/</a></p><p>转自<a href="https://segmentfault.com/a/1190000007250604">青叶-PHP之十六个魔术方法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 魔术方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯视频签到增加V力值</title>
      <link href="/qq-video-sign/"/>
      <url>/qq-video-sign/</url>
      
        <content type="html"><![CDATA[<h1 id="QQVideoSign"><a href="#QQVideoSign" class="headerlink" title="QQVideoSign"></a>QQVideoSign</h1><p>🚀 腾讯视频好莱坞会员V力值签到。</p><p>代码由<a href="https://github.com/sy-records">sy-records</a>的<a href="https://github.com/sy-records/v-checkin/">v-checkin</a>改动而来，额外增加了4项任务的领取，需要手动完成任务才能领取。(通常我是观看60分钟会忘记领)</p><p>执行结果通常是这样的</p><img src="https://github.com/fsql/qqvidoesign/raw/master/images/Result.png" alt="执行结果" data-action="zoom" style="width: 50%"><a id="more"></a><p>下面是使用方法(也是从上面抄来的)</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>注册<a href="http://sc.ftqq.com/">Server酱</a>，获取<code>SCKEY</code>，修改脚本<code>index.py</code>中的<code>sckey</code></p><blockquote><p>用来通知微信提醒签到获得了多少V力值和<strong>Cookie失效</strong>，如果你不打算通知或者有其他方式，可以跳过</p></blockquote></li><li><p>需要一台有<code>Python2</code>环境的<code>Linux</code>服务器或者使用<a href="https://console.cloud.tencent.com/scf">腾讯云Serverless</a></p><blockquote><p>用来定时执行脚本</p></blockquote></li><li><p>获取Cookie</p></li></ul><ol><li>电脑打开浏览器访问<code>v.qq.com</code>，打开控制台(<code>F12</code>)、切换到Network，找到<code>https://access.video.qq.com/user/auth_refresh</code>的接口，把<code>Request URL:</code>后的地址都复制一下，填写到脚本的<code>auth_refresh_url</code>中，如：</li></ol><p><img src="https://github.com/fsql/qqvidoesign/raw/master/images/get-auth_refresh.png" alt="获取auth_refresh接口"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth_refresh_url = <span class="string">&#x27;https://access.video.qq.com/user/auth_refresh?vappid=11059694&amp;vsecret=********&amp;type=qq&amp;g_tk=&amp;g_vstk=********&amp;g_actk=********&amp;callback=jQuery191048649********_1575435********4&amp;_=1575435********&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以搜索<code>auth_refresh</code>进行过滤</p></blockquote><ol start="2"><li>还是<code>auth_refresh</code>这个接口，复制<code>Request Header</code>中的<code>cookie</code>，填写到脚本的<code>login_headers</code>的<code>Cookie</code>中</li></ol><p><img src="https://github.com/fsql/qqvidoesign/raw/master/images/get-cookie.png" alt="获取cookie"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">login_headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://v.qq.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;tvfe_boss_uuid=********; pgv_pvid=********; video_guid=***********; video_platform=2; pgv_info=ssid=***********; pgv_pvi=*************; pgv_si=*************; _qpsvr_localtk=***************; ptisp=; ptui_loginuin=************; RK=*************; ptcz=***************; main_login=qq; vqq_access_token=****************; vqq_appid=101483052; vqq_openid=********************; vqq_vuserid=*********************; vqq_vusession=dzsfo; vqq_refresh_token=*****************; uid=**************;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>重复第二步，粘贴到脚本中的<code>sign_headers</code>的<code>Cookie</code>中，注意修改<code>vqq_vusession</code>，变量<code>cookie[&#39;vqq_vusession&#39;]</code>需要保留不要替换</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sign_headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;tvfe_boss_uuid=***********; pgv_pvid=***************; video_guid=***************; video_platform=2; pgv_info=ssid=****************; pgv_pvi=****************; pgv_si=***************; _qpsvr_localtk=*************; ptisp=; ptui_loginuin=***************; RK=****************; ptcz=*********************; main_login=qq; vqq_access_token=************; vqq_appid=101483052; vqq_openid=*************; vqq_vuserid=*************; vqq_vusession=&#x27;</span> + cookie[<span class="string">&#x27;vqq_vusession&#x27;</span>] + <span class="string">&#x27;;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h2><h3 id="Linux服务器"><a href="#Linux服务器" class="headerlink" title="Linux服务器"></a>Linux服务器</h3><p>使用<code>crontab</code>定时执行就可以了，以下表达式为每天凌晨1点执行一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 * * * python2 /home/www/v-checkin/start.py &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h3 id="腾讯云Serverless"><a href="#腾讯云Serverless" class="headerlink" title="腾讯云Serverless"></a>腾讯云Serverless</h3><p>使用腾讯云云函数来执行，方便没有服务器的同学。首先需要创建函数服务，打开腾讯云<a href="https://console.cloud.tencent.com/scf">云函数 - 控制台</a></p><h4 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h4><ol><li>单击左侧导航栏【函数服务】，进入“函数服务”页面。</li><li>在页面上方选择一个地域，最好选择离你常用地区近点的，不至于导致账号异常。单击【新建】。如下图所示：</li></ol><p><img src="https://github.com/fsql/qqvidoesign/raw/master/images/Serverless-1.png"></p><ol start="3"><li>在“新建函数”页面填写函数基础信息，单击【下一步】。如下图所示：</li></ol><p><img src="https://github.com/fsql/qqvidoesign/raw/master/images/Serverless-2.png"></p><ul><li>函数名称：可以自定义，比如为 <code>v_checkin</code>。</li><li>运行环境：选择 “Python 2.7”。</li><li>创建方式：选择 “空白函数”。</li></ul><ol start="4"><li>填写描述，复制刚才修改好的脚本<code>index.py</code>内容到下面的代码框中，并单击【完成】。如下图所示：</li></ol><p><img src="https://github.com/fsql/qqvidoesign/raw/master/images/Serverless-3.png"></p><p>函数创建完成后，自动进入创建成功函数的“函数配置”页面，可查看该云函数的函数配置信息。</p><p>如果填错了代码，可以在选择【函数代码】中修改，修改完成后记得点击保存；点击【测试】，运行代码，测试结果是成功的话就没有问题了。</p><h4 id="设置触发方式"><a href="#设置触发方式" class="headerlink" title="设置触发方式"></a>设置触发方式</h4><ol><li>在已创建函数的详情页面，选择【触发方式】，并单击【添加触发方式】。如下图所示：</li></ol><p><img src="https://github.com/fsql/qqvidoesign/raw/master/images/Serverless-4.png"></p><ul><li>触发方式：选择 “定时触发”。</li><li>触发周期：选择 “自定义触发周期”。</li><li>Cron表达式：自己填写，如<code>0 0 1 * * * *</code>，表示每天凌晨1点执行一次。Cron表达式不懂的可以参考<a href="https://cloud.tencent.com/document/product/583/9708#cron-.E8.A1.A8.E8.BE.BE.E5.BC.8F">腾讯云文档</a></li></ul><ol start="2"><li>填写完成点击【保存】即可。</li></ol><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://github.com/fsql/qqvidoesign">https://github.com/fsql/qqvidoesign</a></p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抖音无水印解析</title>
      <link href="/get-douyin-video-download-url/"/>
      <url>/get-douyin-video-download-url/</url>
      
        <content type="html"><![CDATA[<p>很早之前就开始写抖音无水印解析，但是抖音更新了很多版本，导致之前的解析方法都失效了，目前这个2020-09-08测试还能用<br><a href="http://v.fsql.net/">demo</a></p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params">$url</span>) </span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_HTTPHEADER, <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4&#x27;</span></span><br><span class="line">    ));</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="literal">False</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="literal">False</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="literal">true</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_TIMEOUT, <span class="number">5000</span>);</span><br><span class="line">    $result = curl_exec($ch);</span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curlGetVideoAddr</span>(<span class="params">$url</span>) </span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_HTTPHEADER, <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4&#x27;</span></span><br><span class="line">    ));</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="literal">False</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="literal">False</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="literal">true</span>);</span><br><span class="line">    curl_setopt($ch, URLINFO_HEADER_OUT, <span class="literal">true</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="literal">true</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_TIMEOUT, <span class="number">5000</span>);</span><br><span class="line">    $result = curl_exec($ch);</span><br><span class="line">    $str = <span class="string">&#x27;/((http:\/\/|https:\/\/)\S+)\s/&#x27;</span>;</span><br><span class="line">    preg_match_all($str,$result,$arr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($arr[<span class="number">0</span>][<span class="number">0</span>]))&#123;</span><br><span class="line">        <span class="keyword">return</span> $arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItemInfo</span>(<span class="params">$url</span>)</span>&#123;</span><br><span class="line">    $str_r= <span class="string">&#x27;/(http:\/\/|https:\/\/)((\w|=|\?|\.|\/|&amp;|-)+)/&#x27;</span>;</span><br><span class="line">    preg_match_all($str_r,$url,$arr);</span><br><span class="line">    $share_url=$arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    $found =  curl($share_url);</span><br><span class="line"></span><br><span class="line">    preg_match(<span class="string">&#x27;/href=&quot;(.*?)&quot;&gt;Found/&#x27;</span>, $found, $matches);</span><br><span class="line">    $url_302 = $matches[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    $str_r= <span class="string">&#x27;/\/video\/(\d+?)\//&#x27;</span>;</span><br><span class="line">    preg_match_all($str_r,$url_302,$arr);</span><br><span class="line"></span><br><span class="line">    $info_url = <span class="string">&#x27;https://www.iesdouyin.com/web/api/v2/aweme/iteminfo/?item_ids=&#x27;</span>.$arr[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    $info = curl($info_url);</span><br><span class="line">    <span class="keyword">return</span> json_decode($info,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_POST[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"></span><br><span class="line">$item_info = getItemInfo($url);</span><br><span class="line"></span><br><span class="line">$play_addr = str_replace(<span class="string">&#x27;playwm&#x27;</span>,<span class="string">&#x27;play&#x27;</span>,$item_info[<span class="string">&#x27;item_list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;video&#x27;</span>][<span class="string">&#x27;play_addr&#x27;</span>][<span class="string">&#x27;url_list&#x27;</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">$play_addr = curlGetVideoAddr($play_addr);</span><br><span class="line"></span><br><span class="line">$data = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;desc&#x27;</span>      =&gt; $item_info[<span class="string">&#x27;item_list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;desc&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;video_url&#x27;</span> =&gt; $play_addr,</span><br><span class="line">    <span class="string">&#x27;music_url&#x27;</span> =&gt; $item_info[<span class="string">&#x27;item_list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;music&#x27;</span>][<span class="string">&#x27;play_url&#x27;</span>][<span class="string">&#x27;uri&#x27;</span>]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode($data);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录Redis重启时遇到的问题</title>
      <link href="/redis-serve-restart-problem/"/>
      <url>/redis-serve-restart-problem/</url>
      
        <content type="html"><![CDATA[<p>记录一次redis重启时无法找到守护进程的问题</p><a id="more"></a><hr><p>公司有个电商平台的项目，基于ThinkPHP5.1框架开发，开始人数不多时使用文件缓存，后来搞了几次活动Inode飙升<br>这样下去肯定不行于是决定把文件缓存改为Redis缓存<br>Redis原本是用于跑订单队列的，默认16个库还空着好几个，于是我决定用15库</p><hr><p>few hours later<br>出问题了，网站打不开了，原因是Redis达到了设置的最大内存(400M)，一个24G内存的服务器只设置了400M的Redis最大内存，好吧这肯定是有问题的，那就改<br>maxmemory设置为18874368000，大概18G。但是在重启Redis的时候遇到了问题</p><p>redis-cli进入后save然后shutdown发现redis进程并未关掉，kill -9也杀不掉进程，看来是有守护进程<br>由于这个服务器的环境不是我配置的，所以当时用什么方法安装的Redis我也不清楚<br>尝试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service redis restart</span><br></pre></td></tr></table></figure><p>提示redis.service not found</p><p>于是进/usr/lib/systemd/system试试看看能不能找到相关服务</p><p>果然，找到了redis-server.service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service redis-server restart</span><br></pre></td></tr></table></figure><p>成功重启，运行十天，内存峰值1290M<br><img src="/images/redis-run-status.png"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇hexo文章，原来的wordpress已经全部舍弃了</title>
      <link href="/first-article/"/>
      <url>/first-article/</url>
      
        <content type="html"><![CDATA[<p>原来WordPress的文章也没有需要保留的价值，所以直接舍弃了<br>第一次用hexo这种纯静态的博客，应该不会像WordPress那样一堆漏洞了吧<br>引入<del>disqus</del>(考虑到墙的问题改为Valine了)以后评论区也会干净许多</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
